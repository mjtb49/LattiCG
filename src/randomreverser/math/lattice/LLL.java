package randomreverser.math.lattice;

import randomreverser.math.component.BigMatrix;
import randomreverser.math.component.BigFraction;
import randomreverser.math.component.BigVector;
import randomreverser.math.component.Vector;

import java.math.BigInteger;
import java.util.Arrays;

public class LLL {

	private LLL() {
	}

	private BigMatrix gramSchmidtBasis;
	private BigMatrix mu;
	private BigMatrix lattice;
	private BigMatrix H;
	private BigFraction[] sizes;
	private Params params;
	private int kmax;
	private int k;
	private boolean shouldUpdateGramSchmidt;
	private static final BigFraction eta = BigFraction.HALF;


    /**
     * LLL lattice reduction implemented as described on page 95 of Henri Cohen's
     * "A course in computational number theory"
     * @param lattice the lattice to reduce
     * @param params the parameters to be passed to LLL
     * @return the reduced lattice
     */
	public static Result reduce(BigMatrix lattice, Params params) {
		return new LLL().reduceLLL(lattice, params);
	}

	/**
	 * LLL lattice reduction implemented as described on page 95 of Henri Cohen's
	 * "A course in computational number theory"
	 * @param lattice the lattice to reduce
	 * @param params the parameters to be passed to LLL
	 * @return the reduced lattice
	 */
	public static Result reduceBKZ(BigMatrix lattice, int blockSize ,Params params) {
		return new LLL().reduceBKZ0(lattice, blockSize,params);
	}

	/**
	 * BKZ reduces a lattice generated by a linearly independant set of vectors.
	 * @param lattice the lattice to BKZ reduce
	 * @param blockSize the blockSize to use in BKZ
	 * @param params the params for the LLL subroutine to reduce its basis to
	 * @return a result encapsulating the lattice and the transformations done by BKZ
	 */
	private Result reduceBKZ0(BigMatrix lattice, int blockSize, Params params) {
		int z = 0;
		int j = 0;
		int beta = blockSize;
		reduceLLL(lattice, params);
		int n = lattice.getRowCount();
		int colCount = lattice.getColumnCount();
		while (z < n - 1) {
			j = (j % (n - 1));
			int k1 = Math.min(j + beta - 1, n);
			int h = Math.min(k1 + 1, n);

			BigFraction[] blockSizes = new BigFraction[k1-j+1];
			for (int i = j; i <= k1; i++) {
				blockSizes[i-j] = sizes[j];
			}

			BigVector v = enumerateBKZ(
					lattice.submatrix(j,0,k1-j+1,colCount),
					mu.submatrix(j,0,k1-j+1,colCount),
					blockSizes
					);

			boolean foundBestVector = (v.get(0).equals(BigFraction.ONE));
			System.out.println(v);
			System.out.println(lattice.submatrix(j,0, k1 - j + 1,colCount).toPrettyString());
			for(int i = 1; i < v.getDimension(); i++) {
				foundBestVector &= v.get(i).equals(BigFraction.ZERO);
			}
			if (!foundBestVector) {
				z = 0;
				BigVector newVec = v.multiply(lattice.submatrix(j,0, k1 - j + 1,colCount));
				BigMatrix newBlock = new BigMatrix(h+1, colCount);
				//can't use submatrix here cuz j might be 1???
                for(int row = 0; row < j - 1; row++) {
                    newBlock.setRow(row, lattice.getRow(row));
                }
                newBlock.setRow(j,newVec);
                for(int row = j; row < h; row++) {
                    newBlock.setRow(row+1, lattice.getRow(row));
                }
                Result result = new LLL().reduceLLL(newBlock,params);
                for (int row = 0; row <= h; row++) {
                    lattice.setRow(row,result.getReducedBasis().getRow(row));
                    mu.setRow(row,result.getGramSchmidtCoefficients().getRow(row));
                    gramSchmidtBasis.setRow(row,result.getGramSchmidtBasis().getRow(row));
                    sizes[row] = result.getGramSchmidtSizes()[row];
                }
			} else {
				z = z+1;
				Result result = new LLL().reduceLLL(lattice.submatrix(0,0,h+1,colCount), params);
                for (int row = 0; row <= h; row++) {
                    lattice.setRow(row,result.getReducedBasis().getRow(row));
                    mu.setRow(row,result.getGramSchmidtCoefficients().getRow(row));
                    gramSchmidtBasis.setRow(row,result.getGramSchmidtBasis().getRow(row));
                    sizes[row] = result.getGramSchmidtSizes()[row];
                }
			}
		}
		return null;
	}

	private BigVector enumerateBKZ(BigMatrix blockLattice, BigMatrix blockMu, BigFraction[] blockSizes) {
		int numRows = blockLattice.getRowCount();

		BigVector currentGuess = new BigVector(numRows+1);
		BigVector bestGuess = new BigVector(numRows+1);
		BigFraction[] y = new BigFraction[numRows+1];
		BigInteger[] triangle = new BigInteger[numRows+1];
		BigFraction[] ctilde = new BigFraction[numRows+1];
		BigInteger[] v = new BigInteger[numRows+1];
		Arrays.fill(v, BigInteger.ZERO);

		BigFraction bestSize = blockSizes[0];
		currentGuess.set(0,BigFraction.ONE);
		bestGuess.set(0,BigFraction.ONE);
		y[0] = BigFraction.ZERO;

		int s = 0, t = 0;
		int[] del = new int[numRows+1];
		for (int i = 1; i <= numRows; i++) {
			ctilde[i] = BigFraction.ZERO;
			bestGuess.set(i, BigFraction.ZERO);
			currentGuess.set(i, BigFraction.ZERO);
			y[i] = BigFraction.ZERO;
			triangle[i] = BigInteger.ZERO;
			del[i] = 1;
		}

		while (t < numRows) {
			BigFraction temp = y[t].add(currentGuess.get(t));
			ctilde[t] =  ctilde[t+1].add(temp.multiply(temp).multiply(blockSizes[t]));

			if (ctilde[t].compareTo(bestSize) < 0) {
				if (t > 0) {
					t = t - 1;
					for (int i = t + 1; i <= s;i++) {
						y[t].add(blockMu.get(i,t).multiply(currentGuess.get(i)));
					}
					v[t] = y[t].round();
					currentGuess.set(t, new BigFraction(v[t]));
					triangle[t] = BigInteger.ZERO;
					if (currentGuess.get(t).compareTo(y[t].multiply(BigFraction.MINUS_ONE)) > 0) {
						del[t] = -1;
					} else {
						del[t] = 1;
					}
				} else {
					bestSize = ctilde[0];
					for (int i = 0; i < numRows; i++) {
						bestGuess.set(i, currentGuess.get(i));
					}
				}
			} else {
				t = t+1;
				s = Math.max(s,t);
				if (t < s) {
					triangle[t] = triangle[t].multiply(BigInteger.valueOf(-1));
				}
				if (triangle[t].multiply(BigInteger.valueOf(del[t])).compareTo(BigInteger.ZERO) >= 0) {
					triangle[t] = triangle[t].add(BigInteger.valueOf(del[t]));
				}
				bestGuess.set(t,new BigFraction( v[t].add(triangle[t])));
			}
		}
		BigVector pleaseWork = new BigVector(numRows);
		for (int i = 0; i < numRows; i ++)
			pleaseWork.set(i,bestGuess.get(i));
		return pleaseWork;
	}

	private Result reduceLLL(BigMatrix lattice, Params params) {
		this.params = params;
		int n = lattice.getRowCount();
		int m = lattice.getColumnCount();
		gramSchmidtBasis = new BigMatrix(n,m);
		mu = new BigMatrix(n,n);
		k = 1;
		kmax = 0;
		gramSchmidtBasis.setRow(0, lattice.getRow(0).copy());
		shouldUpdateGramSchmidt = true;
		H = BigMatrix.identityMatrix(n);
		this.lattice = lattice.copy();
		sizes = new BigFraction[n];
		sizes[0] = this.lattice.getRow(0).magnitudeSq();

		while (k < n) {
			if (k > kmax && shouldUpdateGramSchmidt) {
				kmax = k;
				incGramSchmidt();
			}
			testCondition();
		}

		int p = 0;
		for (int i = 0; i < n; i++) {
			if (this.lattice.getRow(i).isZero()) {
				p++;
			}
		}

		//remova all zero vectors
		BigMatrix nonZeroLattice = this.lattice.submatrix(p,0,n-p,m);

		//update the other local variables to match the removal of zero vectors. Only needed when called as subroutine
		//of BKZ, should perhaps be removed when LLL alone is called. //TODO
		this.lattice = nonZeroLattice;
		gramSchmidtBasis = gramSchmidtBasis.submatrix(p,0,n-p,m);
		mu = mu.submatrix(p,p,n-p,n-p);
		BigFraction[] nonZeroSizes = new BigFraction[n - p];
		for (int i = 0; i < n - p; i++) {
			nonZeroSizes[i] = sizes[i+p];
		}
		sizes = nonZeroSizes;
		return new Result(p,nonZeroLattice,H).setGramSchmidtInfo(gramSchmidtBasis,mu,sizes);
	}

	private void incGramSchmidt() {
		for (int j = 0; j <= k - 1; j++) {
			if (sizes[j].compareTo(BigFraction.ZERO) != 0) {
				mu.set(k, j, lattice.getRow(k).dot(gramSchmidtBasis.getRow(j)).divide(sizes[j]));
			} else {
				mu.set(k, j, BigFraction.ZERO);
			}
		}
		BigVector newRow = lattice.getRow(k).copy();
		for(int i = 0; i <= k - 1; i++) {
			newRow.subtractEquals(gramSchmidtBasis.getRow(i).multiply(mu.get(k,i)));
		}
		gramSchmidtBasis.setRow(k,newRow);
		sizes[k] = newRow.magnitudeSq();
	}

	private void testCondition() {
		red(k,k-1);
		if (sizes[k].toDouble() < ((params.delta - (mu.get(k,k-1).multiply(mu.get(k,k-1))).toDouble())* (sizes[k-1]).toDouble())) { //TODO I don't trust this comparison as doubles
		    swapg(k);
			k = Math.max(1, k-1);
			shouldUpdateGramSchmidt = false;
		} else {
			shouldUpdateGramSchmidt = true;
			for (int l = k - 2; l >= 0; l--) {
				red(k,l);
			}
			k = k+1;
		}
	}

	private void swapg(int n) {
		lattice.swapRowsEquals(n,n-1);
		H.swapRowsEquals(n,n-1);

		if (n > 1) {
			for (int j = 0; j <= n - 2; j++) {
				BigFraction temp = mu.get(n, j);
				mu.set(n, j, mu.get(n - 1, j));
				mu.set(n - 1, j, temp);
			}
		}
		BigFraction mutwopointoh = mu.get(n,n-1);
        BigFraction B = sizes[n].add(mutwopointoh.multiply(mutwopointoh).multiply(sizes[n-1]));

		if (sizes[n].equals(BigFraction.ZERO) && mutwopointoh.equals(BigFraction.ZERO)) {
			BigFraction temp = sizes[n];
			sizes[n] = sizes[n-1];
			sizes[n - 1] = temp;
			gramSchmidtBasis.swapRowsEquals(n,n-1);
			for (int i = n+1; i <= kmax; i++) {
				temp = mu.get(i,n);
				mu.set(i,n, mu.get(i,n-1));
				mu.set(i,n-1, temp);
			}
		}
		else if (sizes[n].equals(BigFraction.ZERO)) {
			sizes[n-1] = B;
			gramSchmidtBasis.getRow(n - 1).multiplyEquals(mutwopointoh);
			mu.set(n,n-1, BigFraction.ONE.divide(mutwopointoh));
			for (int i = n + 1; i <= kmax; i++) {
				mu.set(i,n-1, mu.get(i,n-1).divide(mutwopointoh));
			}
		} else {
			BigFraction t = sizes[n-1].divide(B);
			mu.set(n,n-1, mutwopointoh.multiply(t));
			BigVector b = gramSchmidtBasis.getRow(n-1).copy();
			gramSchmidtBasis.setRow(n-1, gramSchmidtBasis.getRow(n).add(b.multiply(mutwopointoh)));
			gramSchmidtBasis.setRow(n, (b.multiply(sizes[k].divide(B))
					.subtract(gramSchmidtBasis.getRow(n).multiply(mu.get(n,n-1)))));
			sizes[n] = sizes[n].multiply(t);
			sizes[n-1] = B;
			for (int i = n+1; i <= kmax; i++) {
				t = mu.get(i,n);
				mu.set(i,n, mu.get(i,n-1).subtract(mutwopointoh.multiply(t)));
				mu.set(i,n-1, t.add(mu.get(n,n-1).multiply(mu.get(i,n))));
			}
		}
	}

	private void red(int n, int l) {
		if (mu.get(n,l).abs().compareTo(eta) <= 0) {
			return;
		}
		BigFraction q =new BigFraction( mu.get(n,l).round() );
		lattice.setRow(n, lattice.getRow(n).subtract(lattice.getRow(l).multiply(q)));
		H.setRow(n, H.getRow(n).subtract(H.getRow(l).multiply(q)));
		mu.set(n,l, mu.get(n,l).subtract(q));
		for (int i = 0; i <= l-1; i++) {
			mu.set(n,i, mu.get(n,i).subtract(mu.get(l,i).multiply(q)));
		}
	}

	public static final class Params {
		protected double delta = 0.75;
		protected boolean debug;

		public Params setDelta(double delta) {
			this.delta = delta;
			return this;
		}

		public Params setDebug(boolean debug) {
			this.debug = debug;
			return this;
		}
	}

	public static final class Result {
		private int numDependantVectors;
		private BigMatrix reducedBasis;
		private BigMatrix transformationsDone;
		private BigMatrix gramSchmidtBasis;
		private BigMatrix gramSchmidtCoefficients;
		private BigFraction[] gramSchmidtSizes;

		private Result(int numDependantVectors, BigMatrix reducedBasis, BigMatrix transformationsDone) {
			this.numDependantVectors = numDependantVectors;
			this.reducedBasis = reducedBasis;
			this.transformationsDone = transformationsDone;
		}

		private Result setGramSchmidtInfo(BigMatrix gramSchmidtBasis, BigMatrix GSCoefficients, BigFraction[] GSSizes) {
		    this.gramSchmidtBasis = gramSchmidtBasis;
		    this.gramSchmidtCoefficients = GSCoefficients;
		    this.gramSchmidtSizes = GSSizes;
		    return this;
        }

		public int getNumDependantVectors() {
			return numDependantVectors;
		}

		public BigMatrix getReducedBasis() {
			return reducedBasis;
		}

		public BigMatrix getTransformations() {
			return transformationsDone;
		}

		public BigMatrix getGramSchmidtBasis() { return gramSchmidtBasis; }

		public BigMatrix getGramSchmidtCoefficients() { return gramSchmidtCoefficients; }

		public BigFraction[] getGramSchmidtSizes() { return gramSchmidtSizes; }
	}

}
